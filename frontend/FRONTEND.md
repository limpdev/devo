# From HTML » React

Okay, let's integrate the logic `custom.js` into your React `App.jsx` component.

React works differently from traditional JavaScript that manipulates a static HTML DOM. React manages its own virtual DOM and updates the actual DOM efficiently. Directly manipulating the DOM outside of React's control (like using `document.body.innerHTML` or `document.querySelectorAll` globally after initial load) can lead to conflicts and unexpected behavior.

Here's how we can adapt each piece of your `custom.js` logic:

1.  **Callouts (`convertMarkdownCalloutsToHtml`) and Mark Tags (`addMarkTags`):**
    *   These functions operate on the HTML *string* produced by `markdown-it`.
    *   The best place to apply these is *after* `markdown-it` has done its work and *before* you set the `innerHTML` of the `.markdown-content` div.

2.  **Copy Button Logic:**
    *   This logic needs to find elements (`.clip-button`) that are *part of the HTML generated by `markdown-it`* (specifically, by the `markdown-it-highlightjs` plugin, which likely adds these buttons).
    *   Since these buttons aren't React components, we *have* to query the DOM to find them *after* the HTML content has been rendered.
    *   We'll use a `useEffect` hook that runs whenever the HTML content changes. Inside this effect, we'll find the buttons within the rendered content and attach the event listeners. Crucially, we'll also need a *cleanup function* within the `useEffect` to remove these listeners when the content changes again or the component unmounts, preventing memory leaks.

3.  **Ripple Effect:**
    *   This adds a global click listener to the `document`.
    *   We can set this up using a `useEffect` hook that runs only *once* when the `App` component mounts.
    *   Again, we need a cleanup function in the `useEffect` to remove the global listener when the `App` component unmounts.

**Implementation Steps:**

1.  **Move/Import Helper Functions:** Move the `convertMarkdownCalloutsToHtml` and `addMarkTags` functions into your `App.jsx` file (or a separate utility file that you import).
2.  **Modify HTML Processing:** Integrate the callout and mark tag functions into the `useEffect` that processes `currentHtml`.
3.  **Add Effect for Copy Buttons:** Create a new `useEffect` that depends on `currentHtml` to handle attaching/detaching listeners for the copy buttons.
4.  **Add Effect for Ripple:** Create a new `useEffect` with an empty dependency array (`[]`) to set up and tear down the global ripple effect listener.

--- START OF MODIFIED App.jsx ---

```javascript
// frontend/src/App.jsx
import { useState, useEffect, useCallback } from "react";
import * as runtime from "../wailsjs/runtime/runtime";
import { Icon } from "@iconify/react";
import MarkdownIt from "markdown-it";
import markdownItAnchor from "markdown-it-anchor";
import markdownItHighlight from "markdown-it-highlightjs"; // Assumes this adds copy buttons with class 'clip-button'

// Import Go functions
import { GetBookData, GetMarkdownContent } from "../wailsjs/go/main/App";
import { BrowserOpenURL } from "../wailsjs/runtime/runtime";

import TableOfContents from "./components/TableOfContents";
import "./App.css";

// --- Custom JS Logic (Integrated) ---

// CONVERTS GITHUB-STYLE CALLOUTS TO HTML
function convertMarkdownCalloutsToHtml(htmlText) {
	if (!htmlText) return "";
	const calloutTypes = {
		NOTE: '<i class="note-icon">󱞁</i>', // Using appropriate icons or text
		TIP: '<i class="tip-icon">󰴓</i>',
		IMPORTANT: '<i class="important-icon">󱁯</i>',
		WARNING: '<i class="warning-icon">󰉀</i>',
		CAUTION: '<i class="caution-icon"></i>',
	};
	const calloutRegex =
		/<blockquote>\s*<p>\s*\[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\]\s*([\s\S]*?)<\/p>\s*<\/blockquote>/gm;

	return htmlText.replace(calloutRegex, function (match, type, content) {
		const normalizedType = type.toUpperCase();
		const calloutType = Object.keys(calloutTypes).includes(normalizedType) ? normalizedType : "NOTE";
		const processedContent = content.trim(); // Basic trim, React would handle complex tags better if it rendered them

		// Ensure <p> tags wrap content if not already present (markdown-it might add them)
		const finalContent = processedContent.startsWith("<p>") ? processedContent : `<p>${processedContent}</p>`;

		return `<div class="callout callout-${calloutType.toLowerCase()}">
      <div class="callout-header">
        <span class="callout-icon">${calloutTypes[calloutType]}</span>
        <span class="callout-title">${calloutType}</span>
      </div>
      <div class="callout-content">
        ${finalContent}
      </div>
    </div>`;
	});
}

// MARK TAGS FOR TEXT - AKA, Highlighting!
function addMarkTags(text) {
	if (!text) return "";
	const markRegex = /==(.*?)==/g;
	return text.replace(markRegex, `<mark>$1</mark>`);
}

// Logic for handling clicks on dynamically added copy buttons
function setupCopyButtonListeners(containerElement) {
	if (!containerElement) return []; // Return empty array if no container

	const buttons = containerElement.querySelectorAll("pre code.hljs + .clip-button, pre code + .clip-button"); // Be more specific if highlightjs adds button differently
	const listeners = [];

	buttons.forEach((button) => {
		const pre = button.closest("pre");
		const codeBlock = pre ? pre.querySelector("code") : null;

		if (!codeBlock) return; // Skip if structure isn't as expected

		const clickHandler = async () => {
			try {
				await navigator.clipboard.writeText(codeBlock.innerText);

				// --- Visual Feedback ---
				const svg = button.querySelector("svg");
				if (!svg) return; // Skip if no SVG

				// Save original state
				const originalViewBox = svg.getAttribute("viewBox");
				const originalWidth = svg.getAttribute("width");
				const originalHeight = svg.getAttribute("height");
				const originalFill = svg.getAttribute("fill"); // May be null
				const originalHtml = svg.innerHTML;
				const originalAriaLabel = button.getAttribute("aria-label");

				// Apply success state
				svg.innerHTML = ""; // Clear existing paths/etc.
				svg.setAttribute("viewBox", "0 0 24 24");
				// Ensure consistent size, might need adjustment based on original CSS/size
				// svg.setAttribute("width", "1.5em");
				// svg.setAttribute("height", "1.5em");
				svg.setAttribute("fill", "var(--hl-green, green)"); // Use CSS variable or fallback

				const successPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
				successPath.setAttribute(
					"d",
					"M9.5 18.5l-5.5-5.5l1.41-1.41l4.09 4.09l8.59-8.59l1.41 1.41L9.5 18.5z", // Simple checkmark
				);
				svg.appendChild(successPath);
				button.setAttribute("aria-label", "Copied!");
				button.classList.add("copied"); // Add class for potential styling

				// Reset after 2 seconds
				setTimeout(() => {
					svg.innerHTML = originalHtml; // Restore original content
					svg.setAttribute("viewBox", originalViewBox);
					svg.setAttribute("width", originalWidth);
					svg.setAttribute("height", originalHeight);
					if (originalFill) svg.setAttribute("fill", originalFill);
					else svg.removeAttribute("fill");
					button.setAttribute("aria-label", originalAriaLabel || "Copy to clipboard");
					button.classList.remove("copied"); // Remove class
				}, 2000);
			} catch (err) {
				console.error("Failed to copy code:", err);
				button.setAttribute("aria-label", "Copy failed!");
				// Optionally provide visual feedback for error
			}
		};

		button.addEventListener("click", clickHandler);
		// Store the button and handler for cleanup
		listeners.push({ element: button, type: "click", handler: clickHandler });
	});

	return listeners; // Return the array of added listeners
}

// Logic for creating ripple effect on click
function handleGlobalClickForRipple(e) {
	// Ignore clicks on buttons or interactive elements if desired
	if (e.target.closest("button, a, input, select, textarea")) {
		return;
	}

	const rippleContainer = document.createElement("div");
	rippleContainer.style.position = "fixed";
	rippleContainer.style.left = e.clientX - 48 + "px"; // Center 96x96 svg
	rippleContainer.style.top = e.clientY - 48 + "px";
	rippleContainer.style.pointerEvents = "none";
	rippleContainer.style.zIndex = "9999";
	rippleContainer.style.width = "96px";
	rippleContainer.style.height = "96px";
	rippleContainer.style.overflow = "hidden"; // Contain ripple if needed

	const svgNS = "http://www.w3.org/2000/svg";
	const svg = document.createElementNS(svgNS, "svg");
	svg.setAttribute("width", "96");
	svg.setAttribute("height", "96");
	svg.setAttribute("viewBox", "0 0 24 24");

	const circle = document.createElementNS(svgNS, "circle");
	circle.setAttribute("cx", "12");
	circle.setAttribute("cy", "12");
	circle.setAttribute("r", "0");
	// Use a CSS variable or a default color for the ripple
	circle.setAttribute("fill", "var(--ripple-color, rgba(168, 168, 168, 0.7))");
	circle.style.opacity = "1"; // Start fully opaque

	// Use CSS animations instead of SMIL for better compatibility & control
	circle.style.animation = "ripple-radius 0.5s cubic-bezier(.52,.6,.25,.99) forwards, ripple-opacity 0.5s linear 0.1s forwards"; // Delay opacity fade slightly

	svg.appendChild(circle);
	rippleContainer.appendChild(svg);
	document.body.appendChild(rippleContainer);

	// Remove after animation completes (adjust time if animation duration changes)
	setTimeout(() => {
		if (document.body.contains(rippleContainer)) {
			document.body.removeChild(rippleContainer);
		}
	}, 600); // A bit longer than animation duration
}

// Define the CSS animations (add this to your App.css or index.css)
/*
@keyframes ripple-radius {
  to { r: 12; } // Animate radius to fill the 24x24 viewbox
}
@keyframes ripple-opacity {
  to { opacity: 0; }
}
*/

// --- Initialize markdown-it ---
const md = new MarkdownIt({
	html: true,
	linkify: true,
	typographer: true,
})
	.use(markdownItAnchor, {
		permalink: markdownItAnchor.permalink.linkInsideHeader({ // Changed permalink style
            symbol: `<span class="anchor-link" aria-hidden="true">#</span>`,
            placement: 'before',
          }),
		// permalinkSymbol: "#", // Original option
		// permalinkSpace: false, // Original option
	})
	.use(markdownItHighlight, {
        // Optional: configure highlight.js if needed
        // inline: true // Example option
    });

// --- React Component ---
function App() {
	const [toc, setToc] = useState([]);
	const [currentMarkdown, setCurrentMarkdown] = useState("");
	// const [currentHtml, setCurrentHtml] = useState(""); // We process directly before setting innerHTML now
	const [currentPath, setCurrentPath] = useState("");
	const [isLoadingContent, setIsLoadingContent] = useState(true);
	const [initialLoadError, setInitialLoadError] = useState(null);

	const handleMinimize = () => runtime.WindowMinimise();
	const handleClose = () => runtime.Quit();

    // --- Book Loading Logic (useEffect, fetchInitialBookData) --- remains the same

    useEffect(() => {
		const fetchInitialBookData = async () => {
			// ... (fetchInitialBookData logic remains the same)
		};
		fetchInitialBookData();
	}, []);

    // --- Load Chapter Logic (useCallback, loadChapter) --- remains the same

    const loadChapter = useCallback(
        async (relativePath) => {
			// ... (loadChapter logic remains the same)
		},
		[currentPath, currentMarkdown], // Added currentMarkdown dependency here
	);


	// --- Link Handling Logic ---
	const handleLinkClick = useCallback(
		(event) => {
            // ... (handleLinkClick logic remains the same)
        },
		[currentPath, loadChapter],
	);

	// Add global event listener for link clicks *within the content area*
	useEffect(() => {
		const contentArea = document.querySelector(".content-view-wrapper"); // Target the scroll wrapper
		if (contentArea) {
			contentArea.addEventListener("click", handleLinkClick);
			return () => contentArea.removeEventListener("click", handleLinkClick);
		}
	}, [handleLinkClick]); // Re-attach if handler changes

	// --- Image Path Processing ---
	const processImages = useCallback(
		(htmlContent) => {
			// ... (processImages logic remains the same, ensures image paths are correct)
            // Make sure the base path `/frontend/dist/` is correct relative to how Wails serves assets.
            // If assets are served directly from 'book/src', the path might just be '/bookcontent/...'
            // Check Wails AssetServer options. Assuming '/frontend/dist/' maps to your build output.

            if (!htmlContent) return htmlContent;

            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = htmlContent;
            const images = tempDiv.querySelectorAll("img");

            images.forEach((img) => {
                let src = img.getAttribute("src");
                if (!src || src.startsWith("http:") || src.startsWith("https:") || src.startsWith("data:")) return; // Skip absolute URLs and data URIs

                let resolvedSrc;
                if (src.startsWith("/")) {
                     // Absolute path from project root (e.g., /images/pic.png)
                     // Map it to the served asset path
                     resolvedSrc = `/frontend/dist${src}`; // Assumes assets served under /frontend/dist/
                } else {
                     // Relative path (e.g., images/pic.png or ../images/pic.png)
                     const currentDir = currentPath.substring(0, currentPath.lastIndexOf("/") + 1); // folder/ or ""
                     const combinedPath = currentDir + src;

                     // Resolve ., .. segments
                     const parts = combinedPath.split("/");
                     const newParts = [];
                     for (const part of parts) {
                         if (part === "." || part === "") continue;
                         if (part === "..") {
                             if (newParts.length > 0) newParts.pop();
                         } else {
                             newParts.push(part);
                         }
                     }
                     resolvedSrc = `/frontend/dist/${newParts.join("/")}`; // Assumes assets served under /frontend/dist/
                 }
                 console.log(`Image src resolved: ${src} -> ${resolvedSrc}`);
                 img.setAttribute("src", resolvedSrc);

                 // Add error handler for images
                 img.onerror = () => {
                     console.error(`Failed to load image: ${resolvedSrc}`);
                     img.alt = `Failed to load: ${src}`; // Provide feedback
                     // Optionally set a placeholder image
                     // img.src = '/path/to/placeholder.png';
                 };

            });

            return tempDiv.innerHTML;
		},
		[currentPath],
	);

	// --- Process Markdown -> HTML -> Apply Customizations -> Render ---
	useEffect(() => {
        const contentEl = document.querySelector(".markdown-content");
		if (!contentEl) return; // Ensure target element exists

		if (!currentMarkdown) {
            contentEl.innerHTML = ""; // Clear content if markdown is empty
			return;
        }

		try {
			// 1. Render Markdown to HTML
			let htmlContent = md.render(currentMarkdown);

            // 2. Process image paths (needs currentPath)
			htmlContent = processImages(htmlContent);

            // 3. Apply custom HTML transformations (Callouts, Marks)
			htmlContent = convertMarkdownCalloutsToHtml(htmlContent);
			htmlContent = addMarkTags(htmlContent);

            // 4. Set the final HTML
			contentEl.innerHTML = htmlContent;

            // Note: Copy button listeners are handled in a separate effect below
		} catch (error) {
			console.error("Error processing markdown or applying customisations:", error);
            contentEl.innerHTML = `<div class="error">Failed to render content: ${error.message}</div>`;
		}
	}, [currentMarkdown, processImages]); // Rerun when markdown changes or image processing logic changes (due to currentPath)

    // --- Effect for setting up Copy Button Listeners ---
    useEffect(() => {
        const contentEl = document.querySelector(".markdown-content");
        if (!contentEl) return;

        // Setup listeners and get the list of added listeners
        const addedListeners = setupCopyButtonListeners(contentEl);

        // Cleanup function: Remove all listeners added by this effect instance
        return () => {
            addedListeners.forEach(({ element, type, handler }) => {
                element.removeEventListener(type, handler);
            });
        };
    }, [currentMarkdown]); // Rerun when markdown content changes (which implies HTML changed)

    // --- Effect for Global Ripple Effect ---
    useEffect(() => {
        // Add the global click listener
        document.addEventListener("click", handleGlobalClickForRipple);

        // Cleanup function: Remove the global listener when App unmounts
        return () => {
            document.removeEventListener("click", handleGlobalClickForRipple);
        };
    }, []); // Empty dependency array: Runs once on mount, cleans up on unmount

	// --- Render JSX ---
	return (
		<div id="app-container">
			<div className="title-bar" style={{ "--wails-draggable": "drag" }}>
				<div className="title-bar-text">  </div> {/* Consider a proper title */}
				<div className="window-controls">
					<button onClick={handleMinimize} className="window-button minimize" aria-label="Minimize">
						<Icon icon="solar:minimize-square-3-line-duotone" width="11" height="11" style={{ color: "#ffffff40" }} />
					</button>
					<button onClick={handleClose} className="window-button close" aria-label="Close">
						<Icon icon="icon-park-twotone:close-one" width="11" height="11" style={{ color: "#ffffff40" }} />
					</button>
				</div>
			</div>

			<div className="main-layout hide-scrollbar scrollbar-none">
				<TableOfContents tocItems={toc} onItemClick={loadChapter} currentPath={currentPath} />

				<div className="content-view-wrapper hide-scrollbar"> {/* Wrapper for scrolling */}
					{initialLoadError && (
						<div className="error-indicator global-error">
							<h3>Failed to Load Book</h3>
							<pre>{initialLoadError}</pre>
						</div>
					)}
					{/* Loading indicator can be simplified if content clears while loading */}
					{isLoadingContent && currentMarkdown && <div className="loading-indicator content-loading"> Loading Content...</div>}
					{/* The content div is always present, its innerHTML is managed by effects */}
                    <div className="markdown-content hide-scrollbar">
                        {/* Content is injected here by useEffect */}
                        {isLoadingContent && !currentMarkdown && <div className="loading-indicator content-loading">Loading Book...</div>}
                        {!isLoadingContent && !currentMarkdown && !initialLoadError && <div className="info">Select a chapter to view content.</div>}
                    </div>
				</div>
			</div>
		</div>
	);
}

export default App;
```

--- START OF FILE App.css (Additions) ---

```css
/* Add these styles to your existing App.css or index.css */

/* --- Callout Styles --- */
/* (Keep your existing callout styles or adapt these) */
.callout {
  padding: 1rem;
  margin: 1rem 0;
  border-left: 4px solid;
  border-radius: 4px;
  background-color: rgba(128, 128, 128, 0.05); /* Subtle background */
}

.callout-header {
  display: flex;
  align-items: center;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.callout-icon {
  margin-right: 0.5rem;
  font-size: 1.2em; /* Adjust icon size */
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.callout-content p:first-child {
  margin-top: 0;
}
.callout-content p:last-child {
    margin-bottom: 0;
}

.callout-note { border-color: #5e9bff; /* Blue */ }
.callout-note .callout-header { color: #5e9bff; }

.callout-tip { border-color: #37c366; /* Green */ }
.callout-tip .callout-header { color: #37c366; }

.callout-important { border-color: #9c67ff; /* Purple */ }
.callout-important .callout-header { color: #9c67ff; }

.callout-warning { border-color: #f7b731; /* Orange */ }
.callout-warning .callout-header { color: #f7b731; }

.callout-caution { border-color: #f94c4c; /* Red */ }
.callout-caution .callout-header { color: #f94c4c; }

/* --- Mark Tag Style --- */
mark {
  background-color: rgba(255, 255, 0, 0.4); /* Yellowish highlight */
  padding: 0.1em 0.2em;
  border-radius: 3px;
}

/* --- Copy Button Styles --- */
/* Adjust selector if highlightjs adds button differently */
pre > code.hljs + .clip-button,
pre > code + .clip-button {
  position: absolute;
  top: 0.5em;
  right: 0.5em;
  background-color: rgba(128, 128, 128, 0.1);
  border: 1px solid rgba(128, 128, 128, 0.2);
  border-radius: 4px;
  padding: 4px;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity 0.2s ease, background-color 0.2s ease;
  color: #ccc; /* Icon color */
}

pre > code.hljs + .clip-button:hover,
pre > code + .clip-button:hover {
  opacity: 1;
  background-color: rgba(128, 128, 128, 0.2);
}

pre > code.hljs + .clip-button.copied svg,
pre > code + .clip-button.copied svg {
   /* Fill is set inline by JS, use !important only if needed */
   /* fill: var(--hl-green, green) !important;  */
}

/* Ensure pre is relative for absolute positioning of button */
pre {
    position: relative;
}


/* --- Ripple Animation --- */
@keyframes ripple-radius {
  to { r: 12; } /* Animate radius to fill the 24x24 viewbox */
}
@keyframes ripple-opacity {
  0% { opacity: 0.7; } /* Start slightly transparent */
  100% { opacity: 0; }
}

/* --- General Improvements --- */
.markdown-content .anchor-link {
    opacity: 0;
    margin-left: 0.25em;
    color: var(--anchor-link-color, #888);
    text-decoration: none;
    transition: opacity 0.2s ease-in-out;
    font-size: 0.8em; /* Make anchor smaller */
    vertical-align: middle;
}

h1:hover .anchor-link,
h2:hover .anchor-link,
h3:hover .anchor-link,
h4:hover .anchor-link,
h5:hover .anchor-link,
h6:hover .anchor-link {
    opacity: 1;
}

/* Optional: Define CSS variables for colors */
:root {
    --hl-green: #37c366;
    --ripple-color: rgba(168, 168, 168, 0.6);
    --anchor-link-color: #5e9bff80;
}
```

**Explanation of Changes:**

1.  **Helper Functions:** `convertMarkdownCalloutsToHtml`, `addMarkTags`, `setupCopyButtonListeners`, and `handleGlobalClickForRipple` are now defined within or imported into `App.jsx`.
2.  **HTML Processing Effect:** The `useEffect` hook that depends on `currentMarkdown` now performs the sequence:
    *   `md.render(currentMarkdown)`
    *   `processImages(...)`
    *   `convertMarkdownCalloutsToHtml(...)`
    *   `addMarkTags(...)`
    *   Sets `contentEl.innerHTML` with the fully processed HTML string.
3.  **Copy Button Effect:** A *new* `useEffect` hook is added, also depending on `currentMarkdown`.
    *   It runs *after* the HTML is rendered by the previous effect.
    *   It calls `setupCopyButtonListeners`, passing the `.markdown-content` element. This function finds the buttons *within that specific container* and attaches listeners.
    *   Crucially, it returns a *cleanup function*. This function iterates through the listeners that were just added and removes them. React calls this cleanup function before the effect runs again (when `currentMarkdown` changes) or when the `App` component unmounts. This prevents multiple listeners from being attached to the same buttons over time.
    *   The copy button logic inside `setupCopyButtonListeners` is refined slightly for robustness (checking for `codeBlock`, `svg`, using CSS variables).
4.  **Ripple Effect:** A *new* `useEffect` hook with an empty dependency array `[]` is added.
    *   This ensures the effect runs only *once* when the `App` component mounts.
    *   It adds the `handleGlobalClickForRipple` listener to the `document`.
    *   It returns a cleanup function that *removes* this global listener when the `App` component unmounts.
    *   The ripple animation now uses CSS keyframes (`App.css`) instead of SVG SMIL animations for better browser compatibility and separation of concerns.
5.  **Image Processing:** Refined the `processImages` function to better handle absolute paths starting with `/` and relative paths (including `.` and `..`), assuming assets are served relative to `/frontend/dist/`. Added basic `onerror` handling for images. **Remember to adjust `/frontend/dist/` if your Wails asset server configuration is different.**
6.  **Markdown-it Anchor:** Updated the `markdown-it-anchor` configuration to use `permalink.linkInsideHeader` for potentially better styling and accessibility, placing the `#` symbol *before* the header text.
7.  **CSS:** Added necessary CSS for callouts, mark tags, copy buttons (including positioning `pre` relatively), anchor links, and the ripple animation keyframes. Added some CSS variables for easier color theming.
8.  **Minor Cleanup:** Removed the unused `currentHtml` state variable. Improved loading/empty states slightly.

This approach integrates your custom JavaScript logic into the React lifecycle correctly, handling setup and cleanup to avoid common issues like memory leaks or conflicts with React's DOM management.